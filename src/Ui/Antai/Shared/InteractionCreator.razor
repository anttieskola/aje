@inject IJSRuntime JS
@inject ISender Sender
@inject IConnectionMultiplexer Connection
@implements IAsyncDisposable

<div class="container w-9/12 m-1 p-2 rounded-lg rounded-bl-none bg-slate-800 ">
    <div class="container">
        @if (_inputError != null)
        {
            <div class="text-red-500">@_inputError</div>
        }
    </div>
    <div class="flex">
        @if (_inputDisabled)
        {
            <textarea id="disabledInput" class="ml-1 w-full text-sm" spellcheck="false" disabled aria-label="input"
                @bind="_input" @onkeydown="InputKeyDown" rows="@_inputRows">@_input </textarea>
        }
        else
        {
            <textarea id="input" tabindex="0" class="ml-1 w-full text-sm" spellcheck="false" aria-label="input"
                @bind="_input" @onkeydown="InputKeyDown" placeholder="Type your message here" rows="@_inputRows">@_input</textarea>

            <button class="submitButton" @onclick="InputSubmit" aria-label="submit">
                <Icon Name="arrow-return-left" Padding="2" Size="26" />
            </button>
        }
    </div>
</div>

@if (_output != null)
{
    <div class="flex justify-end">
    <div class="container w-11/12 m-1 p-2 rounded-lg rounded-br-none bg-slate-800">
        <textarea id="output" class="mr-1 w-full text-sm" spellcheck="false" disabled aria-label="output"
            rows="@_outputRows">@_output</textarea>
    </div>
</div>
}

@code {
    [Parameter]
    public Guid ChatId { get; set; }

    private IRedisIndex _index = new AiChatIndex();
    private string? _input;
    private string? _inputError;
    private bool _inputDisabled = false;
    private string? _output;
    private IJSObjectReference? _js;
    private int _inputRows = 1;
    private int _outputRows = 1;
    protected override async Task OnInitializedAsync()
    {
        var pubsub = Connection.GetSubscriber();
        await pubsub.SubscribeAsync(_index.Channel, OnMessage);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _js = await JS.InvokeAsync<IJSObjectReference>("import", "./Shared/InteractionCreator.razor.js");
            await _js.InvokeVoidAsync("focusElement", "input");
        }
        await CalculateRows();
    }

    void OnMessage(RedisChannel channel, RedisValue message)
    {
        // TODO: This will write to output on all browsers that have chat open
        // were it is not send, the text outputs into previous output
        if (message.HasValue)
        {
            var msg = JsonSerializer.Deserialize<AiChatEvent>(message.ToString());
            if (msg != null && msg is AiChatTokenEvent tokenEvent && !tokenEvent.IsTest && tokenEvent.ChatId == ChatId)
            {
                InvokeAsync(async () =>
                {
                    _output += tokenEvent.Token;
                    StateHasChanged();
                    if (_js != null)
                        await _js.InvokeVoidAsync("focusElement", "scrollToBottom");
                });
            }
        }
    }

    async Task InputSubmit()
    {
        if (string.IsNullOrWhiteSpace(_input))
        {
            _inputError = "Input cannot be empty";
            return;
        }
        _inputError = null;
        _inputDisabled = true;
        StateHasChanged();
        await Sender.Send(new SendAiChatMessageCommand
            {
                ChatId = ChatId,
                Message = _input,
            });
        await InvokeAsync(Reset);
    }

    async Task Reset()
    {
        // artificial delay
        // TODO: some animation would be nice
        await Task.Delay(TimeSpan.FromMilliseconds(200));
        _inputError = null;
        _input = null;
        _output = null;
        _inputDisabled = false;
        StateHasChanged();

        if (_js is not null)
            await _js.InvokeVoidAsync("focusElement", "input");
    }

    // TODO: Keyevents should be send using SignalR (redis channels) to all browsers that have chat open
    async Task InputKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == null
        || args.CtrlKey
        || args.Key == "Control"
        || args.Key == "Shift"
        || args.Key == "Alt")
            return;

        if (args.Key == "Enter")
            await InputSubmit();

        if (args.Key == "Backspace")
        {
            if (_input?.Length > 0)
            {
                _input = _input.Substring(0, _input.Length - 1);
                StateHasChanged();
            }
        }
        else if (args.Key == "Delete")
        {
            _input = "";
            StateHasChanged();
        }
        else if (args.Key.Length == 1)
        {
            var c = args.Key[0];
            if (IsCharAllowed(c))
            {
                _input += c;
                StateHasChanged();
            }
        }
    }

    bool IsCharAllowed(char c)
    {
        return char.IsLetterOrDigit(c)
        || c == ' '
        || c == '.'
        || c == ','
        || c == '?'
        || c == '!'
        || c == ':'
        || c == ')'
        || c == '('
        || c == '#'
        || c == '\'';
    }

    // TODO: Similar code with InteractionView.razor
    async Task CalculateRows()
    {
        var windowWidth = await JS.InvokeAsync<int>("eval", "window.innerWidth");
        if (!_inputDisabled)
            _inputRows = CalculateRows(_input ?? string.Empty, windowWidth);
        _outputRows = CalculateRows(_output ?? string.Empty, windowWidth);
    }

    int CalculateRows(string text, int windowWidth)
    {
        if (string.IsNullOrWhiteSpace(text))
            return 1;

        // letter width with current settings is around 7...10px
        // width of textare is around 80% of window width
        var columns = (int)(windowWidth * 0.8 / 10);
        var rows = text.Length / columns;
        // add line feeds
        var lineFeeds = text.Count(c => c == '\n');
        rows += lineFeeds;
        // fine tuning
        if (windowWidth < 600)
        {
            // small screen
            if (rows < 5)
                rows += 2;
            else if (rows < 20)
                rows += 3;
            else if (rows < 30)
                rows += 4;
            else
                rows += 5;
        }
        else
        {
            // large screen
            if (rows < 20)
                rows += 2;
        }
        return rows == 0 ? 1 : rows;
    }
    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (_js is not null)
        {
            await _js.DisposeAsync();
        }
    }
}
